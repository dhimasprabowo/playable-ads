<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>3D Model Viewer</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			height: 100vh;
		}

		#gameCanvas {
			width: 100%;
			height: 100%;
			background-color: #fff;
		}

		#joystick {
			position: absolute;
			bottom: 30%;
			left: 50%;
			transform: translate(-50%, 50%);
			width: 350px;
			height: 350px;
		}

		#tutorialScreen {
			position: absolute;
			bottom: 30%;
			left: 50%;
			transform: translate(-50%, 60%);
			width: 350px;
			height: 350px;
			display: flex;
			gap: 5px;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			pointer-events: none;
		}
	</style>
</head>

<body>
	<script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r92/examples/js/loaders/GLTFLoader.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.2/nipplejs.js"></script>
	<script src="https://cdn.tailwindcss.com"></script>
	<!-- <canvas id="gameCanvas" width="300" height="500"></canvas> -->
	<canvas id="gameCanvas"></canvas>
	<div id="joystick"></div>
	<div id="tutorialScreen" class="uppercase bold underline text-xl">
		<div class="animate-bounce">
			Drag to move!
		</div>
		<div class="animate-pulse">
			<img src="/assets/hand.png">
		</div>
	</div>

	<div id="endScreen" class="hidden absolute inset-0 m-auto h-fit w-fit p-2 bg-white rounded-xl uppercase bold text-xl">
		<div class="">
			Game Over
		</div>
	</div>
	<script>
		var showTutorial = true;
		// Get the tutorial screen element
		const tutorialScreen = document.getElementById('tutorialScreen');
		const endScreen = document.getElementById('endScreen');

		var sceneWidth = 400;
		var sceneHeight = 600;

		// Create an empty scene
		var scene = new THREE.Scene();

		// Create a basic perspective camera
		var camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
		// var camera = new THREE.PerspectiveCamera(40, sceneWidth / sceneHeight, 0.1, 1000);
		camera.position.y = 1;
		camera.position.z = 5;
		camera.rotation.x = -0.05

		// Select the canvas from the document
		var canvReference = document.getElementById("gameCanvas");

		// Then pass it to the renderer constructor
		var renderer = new THREE.WebGLRenderer({
			antialias: true,
			canvas: canvReference
		});

		// Configure renderer clear color
		renderer.setClearColor("#000000");

		// Configure renderer size
		renderer.setSize(window.innerWidth, window.innerHeight);
		// renderer.setSize(sceneWidth, sceneHeight);

		// Append Renderer to DOM
		document.body.appendChild(renderer.domElement);

		// ------------------------------------------------
		// FUN STARTS HERE
		// ------------------------------------------------

		//create ground
		var geometryGround = new THREE.BoxGeometry(100, 1, 100);
		var materialGround = new THREE.MeshStandardMaterial({ color: "#433F81" });
		var ground = new THREE.Mesh(geometryGround, materialGround);
		ground.position.set(0, -2, -10);

		// Add cube to Scene
		scene.add(ground);


		// Create a Cube Mesh with basic material
		var geometry = new THREE.BoxGeometry(1, 1, 1);
		// var material = new THREE.MeshPhongMaterial({ color: "#433F81" });
		var material = new THREE.MeshStandardMaterial({ color: "#433F81" });
		var cube = new THREE.Mesh(geometry, material);
		cube.position.set(0, -0.5, -10);
		cube.rotation.set(0, -0.6, 0);

		// Add cube to Scene
		scene.add(cube);

		// Load the 3D model
		/* var target3D;
		const loaderA = new THREE.GLTFLoader();
		loaderA.load(
			'assets/Rider.gltf', // model's path
			function (gltf) {
				target3D = gltf.scene;

				// Scale down the model (e.g., 50% of its original size)
				target3D.scale.set(0.01, 0.01, -0.01); // Scale x, y, and z axes uniformly

				// Apply materials to all meshes in the model
				target3D.traverse((node) => {
					if (node.isMesh) {
						// Example material: a basic colored material
						const textureLoader = new THREE.TextureLoader();
						const texture = textureLoader.load('assets/Colors.png');

						node.material = new THREE.MeshStandardMaterial({
							map: texture,
						});
					}
				});

				// Add the model to the scene
				scene.add(target3D);
				target3D.position.set(0, -0.5, -10);
				target3D.rotation.set(0, -0.6, 0);
			},
			function (xhr) {
				// console.log((xhr.loaded / xhr.total * 100) + '% loaded');
			},
			function (error) {
				console.error('An error occurred', error);
			}
		); */


		// Add a light
		const light = new THREE.DirectionalLight(0xffffff, 1);
		light.position.set(1, 1, 1).normalize();
		scene.add(light);

		// Add a light
		const light2 = new THREE.DirectionalLight(0xffffff, 1);
		light2.position.set(-1, 1, -1).normalize();
		scene.add(light2);


		// Load the 3D model
		var model3D;
		const loader = new THREE.GLTFLoader();
		loader.load(
			'assets/Vehicle.gltf', // model's path
			function (gltf) {
				model3D = gltf.scene;

				// Scale down the model (e.g., 50% of its original size)
				model3D.scale.set(0.01, 0.01, -0.01); // Scale x, y, and z axes uniformly

				// Apply materials to all meshes in the model
				model3D.traverse((node) => {
					if (node.isMesh) {
						// Example material: a basic colored material
						/* node.material = new THREE.MeshStandardMaterial({
							color: 0x00ff00, // Green
							roughness: 0.5,
							metalness: 0.5,
						}); */

						const textureLoader = new THREE.TextureLoader();
						const texture = textureLoader.load('assets/Colors.png');

						node.material = new THREE.MeshStandardMaterial({
							map: texture,
						});
					}
				});

				// Add the model to the scene
				scene.add(model3D);

				model3D.position.y = -1
				// model3D.rotation.y = 3.15
			},
			function (xhr) {
				// console.log((xhr.loaded / xhr.total * 100) + '% loaded');
			},
			function (error) {
				console.error('An error occurred', error);
			}
		);

		const joystickZone = document.getElementById('joystick');
		// Virtual joystick setup
		const joystick = nipplejs.create({
			zone: joystickZone, // Joystick inside the canvas container
			mode: 'static',
			position: { left: '50%', top: '50%' }, // Adjust position as needed
			color: 'white',
			restOpacity: 1,
		});

		/// Movement and rotation state
		let velocity = { forward: 0, rotation: 0 }; // Tracks forward/backward velocity and rotation speed


		// Map joystick movement to model rotation
		joystick.on('move', (evt, data) => {
			if (model3D && data.vector) {
				const movementSpeed = 0.03; // Movement speed multiplier
				const rotationSpeed = 0.01; // Rotation speed multiplier

				velocity.forward = data.vector.y * movementSpeed; // Forward/backward movement
				velocity.rotation = -data.vector.x * rotationSpeed; // Left/right rotation (negative to rotate correctly)
			}
		});

		// Stop movement when joystick is released
		joystick.on('end', () => {
			velocity.forward = 0;
			velocity.rotation = 0;
		});

		let targetCameraPosition = new THREE.Vector3();
		let targetCameraLookAt = new THREE.Vector3();

		// Render Loop
		var render = function () {
			requestAnimationFrame(render);

			// Apply movement and rotation to the model
			if (model3D) {
				// Forward movement
				const forwardVector = new THREE.Vector3(0, 0, -1); // Forward direction in model space
				forwardVector.applyQuaternion(model3D.quaternion); // Rotate to match the model's orientation
				forwardVector.normalize(); // Ensure it's a unit vector

				model3D.position.addScaledVector(forwardVector, velocity.forward);

				// Rotation (around the Y-axis)
				model3D.rotation.y += velocity.rotation;


				if (model3D.position.distanceTo(cube.position) < 1) {
					console.log("TRIGGER");
					endScreen.style.display = 'block'; // show end game
				}


				// Smooth camera follow
				const followDistance = 8; // Distance behind the model
				const heightOffset = 3; // Height offset above the model

				// Calculate the target camera position (behind the model)
				const cameraOffset = new THREE.Vector3(0, heightOffset, followDistance); // Local offset in model space
				cameraOffset.applyQuaternion(model3D.quaternion); // Rotate to align with model's orientation
				targetCameraPosition.copy(model3D.position).add(cameraOffset);

				// Interpolate (lerp) the camera's position for smooth movement
				camera.position.lerp(targetCameraPosition, 0.05);

				// Set the camera to look at the model
				targetCameraLookAt.copy(model3D.position);
				targetCameraLookAt.y += 2; //add offset
				camera.lookAt(targetCameraLookAt);

				if (velocity.forward > 0.01) {
					showTutorial = false;
					tutorialScreen.style.display = 'none'; // Hide tutorial screen
				}

				// console.log(showTutorial);
			}

			// Render the scene
			renderer.render(scene, camera);
		};

		render();
	</script>


</body>

</html>